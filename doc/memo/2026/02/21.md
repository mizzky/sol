## 📝 学習記録：PostgreSQLのUpsertとRETURNINGの挙動
### 1. 今回のクエリの正体
```SQL

INSERT INTO carts(user_id, created_at, updated_at)
VALUES($1, NOW(), NOW())
ON CONFLICT (user_id) 
DO UPDATE SET updated_at = carts.updated_at -- 自信の値を再代入（空打ち）
RETURNING id, user_id, created_at, updated_at;
```
    挙動: 既に user_id が存在する場合、データは1ミリも書き換わらないが、SQL上は「更新処理」として扱われる。

    目的: データの更新ではなく、「既存レコードの id を RETURNING で確実に持ち帰ること」。

### 2. DO NOTHING vs DO UPDATE (空打ち) の比較
項目	DO NOTHING	DO UPDATE (空打ち)
競合時の動作	何もしない	同じ値で上書きする
RETURNINGの結果	空（NULL相当）	既存のIDが返ってくる
メリット	DB負荷が最小限	1回のクエリでIDが確定する
主な用途	重複を無視したいだけ	既存IDを使って次の処理をしたい時
### 3. なぜ「空打ち」が必要なのか？

PostgreSQLの仕様上、INSERT 時に ON CONFLICT DO NOTHING を使うと、衝突が起きた際に「行が処理されなかった」と見なされます。そのため、RETURNING 句を書いていても何も返ってきません。

「新しく作る」か「既存のものを特定する」か、どちらにせよその後の処理で id が必須な場合に、この空打ちテクニックが非常に有効です。
### 4. 応用：もし「更新」もしたいなら

もし「IDも欲しいし、ついでにアクセス時刻も更新したい」なら、以下のように EXCLUDED または NOW() を使います。
```sql
    SET updated_at = EXCLUDED.updated_at（INSERTしようとした値を使う）

    SET updated_at = NOW()（その場の現在時刻を使う）
```

    💡 結論
    この書き方は、**「無駄な SELECT を省いて、1回のリクエストで確実に id をトラッキングするための効率化テクニック」**である。

# カート所有権方針 — クライアントに cart_id を許可しない設計

目的
- クライアントから直接 cart_id を受け取らず、サーバ側でユーザID → cart を解決して操作することで所有権の誤利用を防ぐ。

方針（要点）
- すべての /me/* カート API は認証済みユーザのコンテキスト（ミドルウェアで c.Get("userID")）を使用して操作する。  
- クライアントは cart_id を送らない。必要な識別はサーバが解決する（GetOrCreateCartForUser を利用）。  
- 個別アイテム削除は cart_item_id のみをパスパラメータで受け取り、サーバ側で所有権を検証して削除する。  
- ClearCart は user_id コンテキストのみを使い、そのユーザの cart_id を内部で解決して削除を実行する。

安全なクエリ（例）
- RemoveCartItem（所有権検証付き）
```sql
-- cart_item_id を受け取り、該当 item が user の cart に属する場合のみ削除
DELETE FROM cart_items ci
USING carts c
WHERE ci.id = $1         -- cart_item_id
  AND ci.cart_id = c.id
  AND c.user_id = $2;    -- user_id (サーバ側で渡す)
```

- ClearCart（user_id で解決）
```sql
-- user_id を受け取り、そのユーザの cart の全アイテムを削除
DELETE FROM cart_items
WHERE cart_id = (
  SELECT id FROM carts WHERE user_id = $1
);
```

ハンドラ設計（概略）
- ミドルウェア: AuthRequired() が userID をコンテキストにセットする。  
- DELETE /me/cart/items/:id
  - 取得: path param → cart_item_id  
  - DB 呼び出し: RemoveCartItem(cart_item_id, user_id)（上記 SQL）  
  - 成功: 204 / 失敗（該当なし／所有権不一致）: 404 or 403
- DELETE /me/cart
  - DB 呼び出し: ClearCartByUser(user_id)（上記 SQL）  
  - 成功: 204

テスト要件（TDD）
- 単体テスト（ハンドラ）:
  - 別ユーザの cart_item に対する削除 → 403（または 404 の明確化）  
  - 正常削除 → 204、DB で該当行が消える
- 統合テスト:
  - ClearCart が正しくそのユーザのアイテムのみ削除すること
  - レース条件・並列操作時の整合性（必要に応じてトランザクション）

運用上の注意
- ログに user_id を残す（監査用）。  
- 誤って cart_id を受け取る設計変更をしないよう API ドキュメントに明記する。  
- 既存クライアントへの影響がある場合はマイグレーション計画（互換レイヤ）を用意する。




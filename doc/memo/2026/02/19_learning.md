# 2026-02-19 学習ログ

## 本日取り組んだタスク
- **チケット1 完了**: DB マイグレーション v5 適用（reset_token カラム追加）
- **チケット10 完了**: ユーザー登録ページの実装（フロント）
  - `/register` ページの実装
  - フォーム バリデーション + エラーハンドリング
  - `useAuthStore.register()` との連携
  - 登録成功後 `/login` へリダイレクト
  - Jest テスト 4 件すべてが PASS
- **動作確認**: 登録→ログファイル→ログインの全フロー (E2E) が成功

## 重要な学習ポイント

### 1. マイグレーション（Database Migration）の仕組み
- **概念**: DB スキーマの履歴管理。バージョン管理システムのようなもの
- **ファイル構造**: 
  - `.up.sql`: マイグレーション「進む」
  - `.down.sql`: マイグレーション「戻す」（ロールバック用）
- **migrate ツール**:
  - `golang-migrate` を使用
  - `schema_migrations` テーブルで履歴を記録
  - バージョン番号 (1, 2, 3, ...) で進捗追跡
- **本日の発見**:
  - マイグレーション **ファイル** は 2026-02-17 に作成済み
  - しかし DB に **適用（実行）** されていなかった
  - そのため、フロントから API 呼び出し時に `column "reset_token" does not exist` エラーが発生

### 2. TDD サイクルを回す際の注意点
- **接续**: テストが成功しても、実装の前提条件（例: マイグレーション適用）を確認する
- **根本原因分析**: 500 エラーが出た時、デバッグログを追加して実行フローを追跡
- **積層構造**:
  - フロント（JavaScript/TypeScript）
  - バック（Go/Gin）
  - DB スキーマ
  - この全てが同期していることが重要

### 3. コミットとバージョン管理
- マイグレーション **ファイル作成** と **实際の DB 適用** は異なる作業
- ファイルのコミット ✅ ≠ 実際の環境への適用 ✅
- 複数環境（ローカル、開発環境、本番環境）を想定して、マイグレーション適用フローを構築

## ユーザーからの主な質問と回答

### Q: `db/migrations` ってどういうデータベースなの？
**A**: migrations ディレクトリ自体はファイルシステムです。SQL ファイルを時系列で管理しています。
- 各ファイルは番号（000001, 000002, ...）でバージョン管理
- `migrate` コマンドが「どこまで適用されたか」を DB の `schema_migrations` テーブルで追跡
- つまり、migrations 内のファイルは「設計書」、実際のテーブル変更は PostgreSQL で実行される

### Q: マイグレーションの仕組みはどうなってるの？
**A**:
1. migrate がローカルの `db/migrations` フォルダをスキャン
2. DB の `schema_migrations` テーブルで「どこまで適用済みか」確認
3. 未適用の .up.sql を順番に実行
4. 実行後、schema_migrations に記録

### Q：つまり、ファイルだけ作ってて DB への適用を忘れてたから、500 エラーが出てたってこと？
**A**: その通り。
- 2026-02-17: マイグレーション v5 **ファイル** を作成
- 2026-02-19: ようやく `migrate up` を実行
- この間、DB スキーマと sqlc 生成コードのズレが原因で 500 エラー

## 次のステップ
- チケット11：トップページと管理ページの分離
- チケット12：管理者権限チェックミドルウェア
- これら 2 件でページ構成の整理が完了

---
終了時刻: 2026-02-19

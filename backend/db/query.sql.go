// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addCartItem = `-- name: AddCartItem :one
INSERT INTO cart_items (cart_id, product_id, quantity, price, created_at, updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
ON CONFLICT(cart_id, product_id) DO UPDATE
SET quantity = cart_items.quantity + EXCLUDED.quantity,
    price = EXCLUDED.price,
    updated_at = NOW()
RETURNING id, cart_id, product_id, quantity, price, created_at, updated_at
`

type AddCartItemParams struct {
	CartID    int64 `json:"cart_id"`
	ProductID int64 `json:"product_id"`
	Quantity  int32 `json:"quantity"`
	Price     int64 `json:"price"`
}

// Requires UNIQUE(cart_id, product_id) on cart_items
func (q *Queries) AddCartItem(ctx context.Context, arg AddCartItemParams) (CartItem, error) {
	row := q.db.QueryRowContext(ctx, addCartItem,
		arg.CartID,
		arg.ProductID,
		arg.Quantity,
		arg.Price,
	)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const clearCart = `-- name: ClearCart :exec
DELETE FROM cart_items
WHERE cart_id = $1
`

func (q *Queries) ClearCart(ctx context.Context, cartID int64) error {
	_, err := q.db.ExecContext(ctx, clearCart, cartID)
	return err
}

const clearCartByUser = `-- name: ClearCartByUser :exec
DELETE FROM cart_items
WHERE cart_id = (
    SELECT id FROM carts WHERE user_id = $1
)
`

func (q *Queries) ClearCartByUser(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, clearCartByUser, userID)
	return err
}

const createCart = `-- name: CreateCart :one
 INSERT INTO carts (user_id, created_at, updated_at)
 VALUES($1, NOW(), NOW())
 RETURNING id, user_id, created_at, updated_at
`

func (q *Queries) CreateCart(ctx context.Context, userID int64) (Cart, error) {
	row := q.db.QueryRowContext(ctx, createCart, userID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (
    name, description
) VALUES (
    $1, $2
)
RETURNING id, name, description, created_at, updated_at
`

type CreateCategoryParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, createCategory, arg.Name, arg.Description)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    name, price, is_available, category_id, sku, description, image_url, stock_quantity
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, name, price, is_available, category_id, sku, description, image_url, stock_quantity, created_at, updated_at
`

type CreateProductParams struct {
	Name          string         `json:"name"`
	Price         int32          `json:"price"`
	IsAvailable   bool           `json:"is_available"`
	CategoryID    int64          `json:"category_id"`
	Sku           string         `json:"sku"`
	Description   sql.NullString `json:"description"`
	ImageUrl      sql.NullString `json:"image_url"`
	StockQuantity int32          `json:"stock_quantity"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.Price,
		arg.IsAvailable,
		arg.CategoryID,
		arg.Sku,
		arg.Description,
		arg.ImageUrl,
		arg.StockQuantity,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.IsAvailable,
		&i.CategoryID,
		&i.Sku,
		&i.Description,
		&i.ImageUrl,
		&i.StockQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    name, email, password_hash, role
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, name, email, password_hash, role, status, created_at, updated_at, reset_token
`

type CreateUserParams struct {
	Name         string `json:"name"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
	Role         string `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResetToken,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories
WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getCartByUser = `-- name: GetCartByUser :one
 SELECT id, user_id, created_at, updated_at
 FROM carts
 WHERE user_id = $1
 LIMIT 1
`

func (q *Queries) GetCartByUser(ctx context.Context, userID int64) (Cart, error) {
	row := q.db.QueryRowContext(ctx, getCartByUser, userID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItemByID = `-- name: GetCartItemByID :one
SELECT id, cart_id, product_id, quantity, price, created_at, updated_at
FROM cart_items
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetCartItemByID(ctx context.Context, id int64) (CartItem, error) {
	row := q.db.QueryRowContext(ctx, getCartItemByID, id)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategory = `-- name: GetCategory :one
SELECT id, name, description, created_at, updated_at
FROM categories
WHERE id = $1
`

func (q *Queries) GetCategory(ctx context.Context, id int64) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrCreateCartForUser = `-- name: GetOrCreateCartForUser :one
 INSERT INTO carts(user_id, created_at, updated_at)
 VALUES($1, NOW(), NOW())
 ON CONFLICT (user_id) DO UPDATE SET updated_at = carts.updated_at
 RETURNING id, user_id, created_at, updated_at
`

// Requires UNIQUE(user_id) on carts
func (q *Queries) GetOrCreateCartForUser(ctx context.Context, userID int64) (Cart, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateCartForUser, userID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT
    id, name, price, is_available, category_id, sku, description, image_url, stock_quantity, created_at, updated_at
FROM products
WHERE id = $1
`

func (q *Queries) GetProduct(ctx context.Context, id int64) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.IsAvailable,
		&i.CategoryID,
		&i.Sku,
		&i.Description,
		&i.ImageUrl,
		&i.StockQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password_hash, role, status, created_at, updated_at, reset_token FROM users 
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResetToken,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, password_hash, role, status, created_at, updated_at, reset_token FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResetToken,
	)
	return i, err
}

const getUserForUpdate = `-- name: GetUserForUpdate :one
SELECT id, name, email, password_hash, role, status, created_at, updated_at, reset_token FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserForUpdate(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserForUpdate, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResetToken,
	)
	return i, err
}

const listCartItems = `-- name: ListCartItems :many
 SELECT
    ci.id,
    ci.cart_id,
    ci.product_id,
    ci.quantity,
    ci.price,
    ci.created_at,
    ci.updated_at,
    p.name AS product_name,
    p.price AS product_price,
    p.stock_quantity AS product_stock
FROM cart_items ci
JOIN products p ON p.id = ci.product_id
WHERE ci.cart_id = $1
ORDER BY ci.id
`

type ListCartItemsRow struct {
	ID           int64     `json:"id"`
	CartID       int64     `json:"cart_id"`
	ProductID    int64     `json:"product_id"`
	Quantity     int32     `json:"quantity"`
	Price        int64     `json:"price"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	ProductName  string    `json:"product_name"`
	ProductPrice int32     `json:"product_price"`
	ProductStock int32     `json:"product_stock"`
}

func (q *Queries) ListCartItems(ctx context.Context, cartID int64) ([]ListCartItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCartItems, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCartItemsRow
	for rows.Next() {
		var i ListCartItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.CartID,
			&i.ProductID,
			&i.Quantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCartItemsByUser = `-- name: ListCartItemsByUser :many
SELECT
    ci.id,
    ci.cart_id,
    ci.product_id,
    ci.quantity,
    ci.price,
    ci.created_at,
    ci.updated_at,
    p.name AS product_name,
    p.price AS product_price,
    p.stock_quantity AS product_stock
FROM cart_items ci
JOIN carts c ON ci.cart_id = c.id
JOIN products p ON p.id = ci.product_id
WHERE c.user_id = $1
ORDER BY ci.id
`

type ListCartItemsByUserRow struct {
	ID           int64     `json:"id"`
	CartID       int64     `json:"cart_id"`
	ProductID    int64     `json:"product_id"`
	Quantity     int32     `json:"quantity"`
	Price        int64     `json:"price"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	ProductName  string    `json:"product_name"`
	ProductPrice int32     `json:"product_price"`
	ProductStock int32     `json:"product_stock"`
}

func (q *Queries) ListCartItemsByUser(ctx context.Context, userID int64) ([]ListCartItemsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listCartItemsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCartItemsByUserRow
	for rows.Next() {
		var i ListCartItemsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.CartID,
			&i.ProductID,
			&i.Quantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, description, created_at, updated_at
FROM categories
ORDER BY name
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT
    id, name, price, is_available, category_id, sku, description, image_url, stock_quantity, created_at, updated_at
FROM products
ORDER BY id
`

func (q *Queries) ListProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.IsAvailable,
			&i.CategoryID,
			&i.Sku,
			&i.Description,
			&i.ImageUrl,
			&i.StockQuantity,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCartItem = `-- name: RemoveCartItem :exec
DELETE FROM cart_items
WHERE id = $1
`

func (q *Queries) RemoveCartItem(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, removeCartItem, id)
	return err
}

const removeCartItemByUser = `-- name: RemoveCartItemByUser :exec
DELETE FROM cart_items ci
USING carts c
WHERE ci.id = $1
AND ci.cart_id = c.id
AND c.user_id = $2
`

type RemoveCartItemByUserParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) RemoveCartItemByUser(ctx context.Context, arg RemoveCartItemByUserParams) error {
	_, err := q.db.ExecContext(ctx, removeCartItemByUser, arg.ID, arg.UserID)
	return err
}

const setResetToken = `-- name: SetResetToken :one
UPDATE users
SET reset_token = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, name, email, password_hash, role, status, created_at, updated_at, reset_token
`

type SetResetTokenParams struct {
	ResetToken sql.NullString `json:"reset_token"`
	ID         int64          `json:"id"`
}

func (q *Queries) SetResetToken(ctx context.Context, arg SetResetTokenParams) (User, error) {
	row := q.db.QueryRowContext(ctx, setResetToken, arg.ResetToken, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResetToken,
	)
	return i, err
}

const updateCartItemQty = `-- name: UpdateCartItemQty :one
UPDATE cart_items
SET quantity = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, cart_id, product_id, quantity, price, created_at, updated_at
`

type UpdateCartItemQtyParams struct {
	ID       int64 `json:"id"`
	Quantity int32 `json:"quantity"`
}

func (q *Queries) UpdateCartItemQty(ctx context.Context, arg UpdateCartItemQtyParams) (CartItem, error) {
	row := q.db.QueryRowContext(ctx, updateCartItemQty, arg.ID, arg.Quantity)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCartItemQtyByUser = `-- name: UpdateCartItemQtyByUser :one
UPDATE cart_items ci
SET quantity = $2, updated_at = NOW()
FROM carts c
WHERE ci.id = $1
and ci.cart_id = c.id
AND c.user_id = $3
RETURNING ci.id, ci.cart_id, ci.product_id, ci.quantity, ci.price, ci.created_at, ci.updated_at
`

type UpdateCartItemQtyByUserParams struct {
	ID       int64 `json:"id"`
	Quantity int32 `json:"quantity"`
	UserID   int64 `json:"user_id"`
}

func (q *Queries) UpdateCartItemQtyByUser(ctx context.Context, arg UpdateCartItemQtyByUserParams) (CartItem, error) {
	row := q.db.QueryRowContext(ctx, updateCartItemQtyByUser, arg.ID, arg.Quantity, arg.UserID)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET
    name = $2,
    description = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, created_at, updated_at
`

type UpdateCategoryParams struct {
	ID          int64          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, updateCategory, arg.ID, arg.Name, arg.Description)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
    name = COALESCE($1, name),
    price = COALESCE($2, price),
    is_available = COALESCE($3, is_available),
    category_id = COALESCE($4, category_id),
    sku = COALESCE($5, sku),
    description = COALESCE($6, description),
    image_url = COALESCE($7, image_url),
    stock_quantity = COALESCE($8, stock_quantity),
    updated_at = NOW()
WHERE id = $9
RETURNING id, name, price, is_available, category_id, sku, description, image_url, stock_quantity, created_at, updated_at
`

type UpdateProductParams struct {
	Name          string         `json:"name"`
	Price         int32          `json:"price"`
	IsAvailable   bool           `json:"is_available"`
	CategoryID    int64          `json:"category_id"`
	Sku           string         `json:"sku"`
	Description   sql.NullString `json:"description"`
	ImageUrl      sql.NullString `json:"image_url"`
	StockQuantity int32          `json:"stock_quantity"`
	ID            int64          `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.Name,
		arg.Price,
		arg.IsAvailable,
		arg.CategoryID,
		arg.Sku,
		arg.Description,
		arg.ImageUrl,
		arg.StockQuantity,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.IsAvailable,
		&i.CategoryID,
		&i.Sku,
		&i.Description,
		&i.ImageUrl,
		&i.StockQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE users
SET role = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, name, email, password_hash, role, status, created_at, updated_at, reset_token
`

type UpdateUserRoleParams struct {
	Role string `json:"role"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserRole, arg.Role, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResetToken,
	)
	return i, err
}
